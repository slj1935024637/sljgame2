{"ast":null,"code":"import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode, createStaticVNode as _createStaticVNode } from \"vue\";\nvar _hoisted_1 = {\n  \"class\": \"snake-game\"\n};\nvar _hoisted_2 = {\n  \"class\": \"game-header\"\n};\nvar _hoisted_3 = {\n  \"class\": \"score-container\"\n};\nvar _hoisted_4 = {\n  \"class\": \"score\"\n};\nvar _hoisted_5 = {\n  \"class\": \"value\"\n};\nvar _hoisted_6 = {\n  \"class\": \"high-score\"\n};\nvar _hoisted_7 = {\n  \"class\": \"value\"\n};\nvar _hoisted_8 = [\"width\", \"height\"];\nvar _hoisted_9 = {\n  key: 0,\n  \"class\": \"game-over\"\n};\nvar _hoisted_10 = {\n  \"class\": \"game-over-content\"\n};\nvar _hoisted_11 = {\n  \"class\": \"final-score\"\n};\nvar _hoisted_12 = {\n  \"class\": \"value\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createElementVNode(\"div\", _hoisted_2, [_createElementVNode(\"div\", _hoisted_3, [_createElementVNode(\"div\", _hoisted_4, [_cache[1] || (_cache[1] = _createElementVNode(\"span\", {\n    \"class\": \"label\"\n  }, \"分数\", -1)), _createElementVNode(\"span\", _hoisted_5, _toDisplayString($setup.score), 1)]), _createElementVNode(\"div\", _hoisted_6, [_cache[2] || (_cache[2] = _createElementVNode(\"span\", {\n    \"class\": \"label\"\n  }, \"最高分\", -1)), _createElementVNode(\"span\", _hoisted_7, _toDisplayString($setup.highScore), 1)])]), _cache[3] || (_cache[3] = _createStaticVNode(\"<div class=\\\"controls-info\\\" data-v-12e86f5c><div class=\\\"key\\\" data-v-12e86f5c>↑</div><div class=\\\"key-row\\\" data-v-12e86f5c><div class=\\\"key\\\" data-v-12e86f5c>←</div><div class=\\\"key\\\" data-v-12e86f5c>↓</div><div class=\\\"key\\\" data-v-12e86f5c>→</div></div><div class=\\\"key-label\\\" data-v-12e86f5c>方向键控制</div></div>\", 1))]), _createElementVNode(\"canvas\", {\n    ref: \"gameCanvas\",\n    width: $setup.canvasWidth,\n    height: $setup.canvasHeight\n  }, null, 8, _hoisted_8), $setup.gameOver ? (_openBlock(), _createElementBlock(\"div\", _hoisted_9, [_createElementVNode(\"div\", _hoisted_10, [_cache[6] || (_cache[6] = _createElementVNode(\"h2\", null, \"游戏结束\", -1)), _createElementVNode(\"div\", _hoisted_11, [_cache[4] || (_cache[4] = _createElementVNode(\"span\", {\n    \"class\": \"label\"\n  }, \"最终得分\", -1)), _createElementVNode(\"span\", _hoisted_12, _toDisplayString($setup.score), 1)]), _createElementVNode(\"button\", {\n    onClick: _cache[0] || (_cache[0] = function () {\n      return $setup.restartGame && $setup.restartGame.apply($setup, arguments);\n    }),\n    \"class\": \"restart-btn\"\n  }, _cache[5] || (_cache[5] = [_createElementVNode(\"span\", {\n    \"class\": \"btn-text\"\n  }, \"重新开始\", -1), _createElementVNode(\"span\", {\n    \"class\": \"btn-icon\"\n  }, \"↺\", -1)]))])])) : _createCommentVNode(\"\", true)]);\n}","map":{"version":3,"names":["key","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","_hoisted_3","_hoisted_4","_hoisted_5","_toDisplayString","$setup","score","_hoisted_6","_hoisted_7","highScore","_createStaticVNode","ref","width","canvasWidth","height","canvasHeight","_hoisted_8","gameOver","_hoisted_9","_hoisted_10","_hoisted_11","_hoisted_12","onClick","_cache","restartGame","apply","arguments","_createCommentVNode"],"sources":["d:\\slj_doc\\game_2\\src\\components\\SnakeGame.vue"],"sourcesContent":["<template>\n  <div class=\"snake-game\">\n    <div class=\"game-header\">\n      <div class=\"score-container\">\n        <div class=\"score\">\n          <span class=\"label\">分数</span>\n          <span class=\"value\">{{ score }}</span>\n        </div>\n        <div class=\"high-score\">\n          <span class=\"label\">最高分</span>\n          <span class=\"value\">{{ highScore }}</span>\n        </div>\n      </div>\n      <div class=\"controls-info\">\n        <div class=\"key\">↑</div>\n        <div class=\"key-row\">\n          <div class=\"key\">←</div>\n          <div class=\"key\">↓</div>\n          <div class=\"key\">→</div>\n        </div>\n        <div class=\"key-label\">方向键控制</div>\n      </div>\n    </div>\n    \n    <canvas ref=\"gameCanvas\" :width=\"canvasWidth\" :height=\"canvasHeight\"></canvas>\n    \n    <div v-if=\"gameOver\" class=\"game-over\">\n      <div class=\"game-over-content\">\n        <h2>游戏结束</h2>\n        <div class=\"final-score\">\n          <span class=\"label\">最终得分</span>\n          <span class=\"value\">{{ score }}</span>\n        </div>\n        <button @click=\"restartGame\" class=\"restart-btn\">\n          <span class=\"btn-text\">重新开始</span>\n          <span class=\"btn-icon\">↺</span>\n        </button>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nexport default {\n  name: 'SnakeGame',\n  setup() {\n    const gameCanvas = ref(null)\n    const canvasWidth = 600\n    const canvasHeight = 400\n    const gridSize = 20\n    const score = ref(0)\n    const highScore = ref(localStorage.getItem('snakeHighScore') || 0)\n    const gameOver = ref(false)\n    const particles = ref([])\n    const gameStarted = ref(false)\n\n    let ctx\n    let snake = []\n    let food = {}\n    let direction = 'right'\n    let nextDirection = 'right'\n    let gameLoop\n    let particleLoop\n\n    const initGame = () => {\n      // 初始化蛇\n      snake = [\n        { x: 6, y: 10 },\n        { x: 5, y: 10 },\n        { x: 4, y: 10 }\n      ]\n      \n      // 生成第一个食物\n      generateFood()\n      \n      // 重置游戏状态\n      score.value = 0\n      gameOver.value = false\n      direction = 'right'\n      nextDirection = 'right'\n      particles.value = []\n      gameStarted.value = true\n      \n      // 开始游戏循环\n      if (gameLoop) clearInterval(gameLoop)\n      if (particleLoop) clearInterval(particleLoop)\n      \n      gameLoop = setInterval(updateGame, 100)\n      particleLoop = setInterval(updateParticles, 16)\n    }\n\n    const generateFood = () => {\n      const maxX = Math.floor(canvasWidth / gridSize) - 1\n      const maxY = Math.floor(canvasHeight / gridSize) - 1\n      \n      let newFood\n      do {\n        newFood = {\n          x: Math.floor(Math.random() * maxX),\n          y: Math.floor(Math.random() * maxY)\n        }\n      } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y))\n      \n      food = newFood\n      \n      // 生成食物出现特效\n      createFoodEffect(food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2)\n    }\n\n    const createFoodEffect = (x, y) => {\n      for (let i = 0; i < 10; i++) {\n        const angle = (Math.PI * 2 / 10) * i\n        particles.value.push({\n          x,\n          y,\n          vx: Math.cos(angle) * 2,\n          vy: Math.sin(angle) * 2,\n          life: 1,\n          color: '#e74c3c',\n          size: 3\n        })\n      }\n    }\n\n    const createSnakeEffect = (x, y) => {\n      for (let i = 0; i < 5; i++) {\n        particles.value.push({\n          x: x + Math.random() * gridSize,\n          y: y + Math.random() * gridSize,\n          vx: (Math.random() - 0.5) * 2,\n          vy: (Math.random() - 0.5) * 2,\n          life: 0.8,\n          color: '#4cd137',\n          size: 2\n        })\n      }\n    }\n\n    const updateParticles = () => {\n      particles.value = particles.value.filter(particle => {\n        particle.x += particle.vx\n        particle.y += particle.vy\n        particle.life -= 0.02\n        particle.size -= 0.05\n        return particle.life > 0 && particle.size > 0\n      })\n    }\n\n    const updateGame = () => {\n      if (gameOver.value) return\n\n      // 更新方向\n      direction = nextDirection\n\n      // 计算新的头部位置\n      const head = { ...snake[0] }\n      switch (direction) {\n        case 'up':\n          head.y--\n          break\n        case 'down':\n          head.y++\n          break\n        case 'left':\n          head.x--\n          break\n        case 'right':\n          head.x++\n          break\n      }\n\n      // 检查碰撞\n      if (checkCollision(head)) {\n        endGame()\n        return\n      }\n\n      // 移动蛇\n      snake.unshift(head)\n      createSnakeEffect(head.x * gridSize, head.y * gridSize)\n\n      // 检查是否吃到食物\n      if (head.x === food.x && head.y === food.y) {\n        score.value += 10\n        if (score.value > highScore.value) {\n          highScore.value = score.value\n          localStorage.setItem('snakeHighScore', highScore.value)\n        }\n        generateFood()\n      } else {\n        snake.pop()\n      }\n\n      // 绘制游戏\n      drawGame()\n    }\n\n    const drawGame = () => {\n      if (!ctx) return\n\n      // 绘制背景\n      ctx.fillStyle = '#1a1a1a'\n      ctx.fillRect(0, 0, canvasWidth, canvasHeight)\n\n      // 绘制网格\n      drawGrid()\n\n      // 绘制粒子\n      particles.value.forEach(particle => {\n        ctx.fillStyle = `${particle.color}${Math.floor(particle.life * 255).toString(16).padStart(2, '0')}`\n        ctx.beginPath()\n        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2)\n        ctx.fill()\n      })\n\n      // 绘制蛇\n      snake.forEach((segment, index) => {\n        const x = segment.x * gridSize\n        const y = segment.y * gridSize\n        \n        ctx.fillStyle = index === 0 ? '#4cd137' : '#20bf6b'\n        ctx.shadowColor = '#4cd137'\n        ctx.shadowBlur = 10\n        \n        roundRect(ctx, x, y, gridSize - 1, gridSize - 1, 4)\n        ctx.fill()\n        \n        ctx.shadowBlur = 0\n      })\n\n      // 绘制食物\n      const foodX = food.x * gridSize + gridSize/2\n      const foodY = food.y * gridSize + gridSize/2\n      const pulseSize = Math.sin(Date.now() / 200) * 2\n\n      ctx.fillStyle = '#e74c3c'\n      ctx.shadowColor = '#e74c3c'\n      ctx.shadowBlur = 15\n      \n      // 绘制主体\n      ctx.beginPath()\n      ctx.arc(foodX, foodY, gridSize/3, 0, Math.PI * 2)\n      ctx.fill()\n      \n      // 绘制光晕\n      ctx.globalAlpha = 0.3\n      ctx.beginPath()\n      ctx.arc(foodX, foodY, gridSize/3 + pulseSize, 0, Math.PI * 2)\n      ctx.fill()\n      ctx.globalAlpha = 1.0\n      \n      ctx.shadowBlur = 0\n    }\n\n    const drawGrid = () => {\n      ctx.strokeStyle = '#2c3e50'\n      ctx.lineWidth = 0.5\n      \n      // 绘制垂直线\n      for (let x = 0; x <= canvasWidth; x += gridSize) {\n        ctx.beginPath()\n        ctx.moveTo(x, 0)\n        ctx.lineTo(x, canvasHeight)\n        ctx.stroke()\n      }\n      \n      // 绘制水平线\n      for (let y = 0; y <= canvasHeight; y += gridSize) {\n        ctx.beginPath()\n        ctx.moveTo(0, y)\n        ctx.lineTo(canvasWidth, y)\n        ctx.stroke()\n      }\n    }\n\n    const roundRect = (ctx, x, y, width, height, radius) => {\n      ctx.beginPath()\n      ctx.moveTo(x + radius, y)\n      ctx.lineTo(x + width - radius, y)\n      ctx.quadraticCurveTo(x + width, y, x + width, y + radius)\n      ctx.lineTo(x + width, y + height - radius)\n      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height)\n      ctx.lineTo(x + radius, y + height)\n      ctx.quadraticCurveTo(x, y + height, x, y + height - radius)\n      ctx.lineTo(x, y + radius)\n      ctx.quadraticCurveTo(x, y, x + radius, y)\n      ctx.closePath()\n    }\n\n    const checkCollision = (head) => {\n      // 检查墙壁碰撞\n      if (head.x < 0 || head.x >= canvasWidth / gridSize ||\n          head.y < 0 || head.y >= canvasHeight / gridSize) {\n        return true\n      }\n\n      // 检查自身碰撞\n      return snake.some(segment => segment.x === head.x && segment.y === head.y)\n    }\n\n    const handleKeydown = (e) => {\n      if (!gameStarted.value) {\n        initGame()\n        return\n      }\n\n      switch (e.key) {\n        case 'ArrowUp':\n          if (direction !== 'down') nextDirection = 'up'\n          break\n        case 'ArrowDown':\n          if (direction !== 'up') nextDirection = 'down'\n          break\n        case 'ArrowLeft':\n          if (direction !== 'right') nextDirection = 'left'\n          break\n        case 'ArrowRight':\n          if (direction !== 'left') nextDirection = 'right'\n          break\n      }\n    }\n\n    const endGame = () => {\n      gameOver.value = true\n      gameStarted.value = false\n      clearInterval(gameLoop)\n      clearInterval(particleLoop)\n      \n      // 生成爆炸效果\n      for (let i = 0; i < 30; i++) {\n        const angle = Math.random() * Math.PI * 2\n        const speed = Math.random() * 4 + 2\n        particles.value.push({\n          x: snake[0].x * gridSize + gridSize/2,\n          y: snake[0].y * gridSize + gridSize/2,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed,\n          life: 1,\n          color: '#e74c3c',\n          size: Math.random() * 4 + 2\n        })\n      }\n    }\n\n    const restartGame = () => {\n      initGame()\n    }\n\n    onMounted(() => {\n      ctx = gameCanvas.value.getContext('2d')\n      window.addEventListener('keydown', handleKeydown)\n      drawGame() // 绘制初始状态\n    })\n\n    onUnmounted(() => {\n      window.removeEventListener('keydown', handleKeydown)\n      clearInterval(gameLoop)\n      clearInterval(particleLoop)\n    })\n\n    return {\n      gameCanvas,\n      canvasWidth,\n      canvasHeight,\n      score,\n      highScore,\n      gameOver,\n      gameStarted,\n      restartGame\n    }\n  }\n}\n</script>\n\n<style scoped>\n.snake-game {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 2rem;\n  padding: 2rem;\n  background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);\n  border-radius: 16px;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.game-header {\n  display: flex;\n  justify-content: space-between;\n  width: 100%;\n  max-width: 600px;\n}\n\n.score-container {\n  display: flex;\n  gap: 2rem;\n}\n\n.score, .high-score {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  background: rgba(255, 255, 255, 0.1);\n  padding: 1rem 2rem;\n  border-radius: 12px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);\n}\n\n.label {\n  font-size: 0.9rem;\n  color: #95a5a6;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n}\n\n.value {\n  font-size: 2rem;\n  font-weight: bold;\n  color: #ecf0f1;\n  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.controls-info {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.key-row {\n  display: flex;\n  gap: 0.5rem;\n}\n\n.key {\n  width: 40px;\n  height: 40px;\n  background: rgba(255, 255, 255, 0.1);\n  border: 2px solid rgba(255, 255, 255, 0.2);\n  border-radius: 8px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: #ecf0f1;\n  font-size: 1.2rem;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\n}\n\n.key-label {\n  color: #95a5a6;\n  font-size: 0.8rem;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n}\n\ncanvas {\n  border: 4px solid rgba(255, 255, 255, 0.1);\n  border-radius: 12px;\n  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);\n}\n\n.game-over {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.8);\n  backdrop-filter: blur(8px);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.game-over-content {\n  background: rgba(255, 255, 255, 0.1);\n  padding: 3rem;\n  border-radius: 16px;\n  text-align: center;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.game-over h2 {\n  font-size: 2.5rem;\n  color: #ecf0f1;\n  margin-bottom: 2rem;\n  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.final-score {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-bottom: 2rem;\n}\n\n.restart-btn {\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n  padding: 1rem 2rem;\n  font-size: 1.2rem;\n  background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);\n  color: white;\n  border: none;\n  border-radius: 8px;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);\n}\n\n.restart-btn:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 6px 16px rgba(231, 76, 60, 0.4);\n}\n\n.btn-text {\n  font-weight: bold;\n  letter-spacing: 1px;\n}\n\n.btn-icon {\n  font-size: 1.5rem;\n}\n\n@keyframes pulse {\n  0% { transform: scale(1); }\n  50% { transform: scale(1.05); }\n  100% { transform: scale(1); }\n}\n\n.score.highlight {\n  animation: pulse 0.3s ease;\n}\n</style>\n"],"mappings":";;EACO,SAAM;AAAY;;EAChB,SAAM;AAAa;;EACjB,SAAM;AAAiB;;EACrB,SAAM;AAAO;;EAEV,SAAM;AAAO;;EAEhB,SAAM;AAAY;;EAEf,SAAM;AAAO;iBAV7B;;EAAAA,GAAA;EA0ByB,SAAM;;;EACpB,SAAM;AAAmB;;EAEvB,SAAM;AAAa;;EAEhB,SAAM;AAAO;;uBA9B3BC,mBAAA,CAsCM,OAtCNC,UAsCM,GArCJC,mBAAA,CAoBM,OApBNC,UAoBM,GAnBJD,mBAAA,CASM,OATNE,UASM,GARJF,mBAAA,CAGM,OAHNG,UAGM,G,0BAFJH,mBAAA,CAA6B;IAAvB,SAAM;EAAO,GAAC,IAAE,QACtBA,mBAAA,CAAsC,QAAtCI,UAAsC,EAAAC,gBAAA,CAAfC,MAAA,CAAAC,KAAK,M,GAE9BP,mBAAA,CAGM,OAHNQ,UAGM,G,0BAFJR,mBAAA,CAA8B;IAAxB,SAAM;EAAO,GAAC,KAAG,QACvBA,mBAAA,CAA0C,QAA1CS,UAA0C,EAAAJ,gBAAA,CAAnBC,MAAA,CAAAI,SAAS,M,+BAV1CC,kBAAA,qU,GAwBIX,mBAAA,CAA8E;IAAtEY,GAAG,EAAC,YAAY;IAAEC,KAAK,EAAEP,MAAA,CAAAQ,WAAW;IAAGC,MAAM,EAAET,MAAA,CAAAU;cAxB3DC,UAAA,GA0BeX,MAAA,CAAAY,QAAQ,I,cAAnBpB,mBAAA,CAYM,OAZNqB,UAYM,GAXJnB,mBAAA,CAUM,OAVNoB,WAUM,G,0BATJpB,mBAAA,CAAa,YAAT,MAAI,QACRA,mBAAA,CAGM,OAHNqB,WAGM,G,0BAFJrB,mBAAA,CAA+B;IAAzB,SAAM;EAAO,GAAC,MAAI,QACxBA,mBAAA,CAAsC,QAAtCsB,WAAsC,EAAAjB,gBAAA,CAAfC,MAAA,CAAAC,KAAK,M,GAE9BP,mBAAA,CAGS;IAHAuB,OAAK,EAAAC,MAAA,QAAAA,MAAA;MAAA,OAAElB,MAAA,CAAAmB,WAAA,IAAAnB,MAAA,CAAAmB,WAAA,CAAAC,KAAA,CAAApB,MAAA,EAAAqB,SAAA,CAAW;IAAA;IAAE,SAAM;gCACjC3B,mBAAA,CAAkC;IAA5B,SAAM;EAAU,GAAC,MAAI,OAC3BA,mBAAA,CAA+B;IAAzB,SAAM;EAAU,GAAC,GAAC,M,UAnClC4B,mBAAA,W","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}