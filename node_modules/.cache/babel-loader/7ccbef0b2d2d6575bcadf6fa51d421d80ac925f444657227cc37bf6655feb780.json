{"ast":null,"code":"import _classCallCheck from \"D:/slj_doc/game_2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/slj_doc/game_2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nvar TerrainGenerator = /*#__PURE__*/function () {\n  function TerrainGenerator(width, height) {\n    var tileSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n    _classCallCheck(this, TerrainGenerator);\n    this.width = width;\n    this.height = height;\n    this.tileSize = tileSize;\n\n    // 地形配置\n    this.platformMinWidth = 3;\n    this.platformMaxWidth = 8;\n    this.platformMinGap = 2;\n    this.platformMaxGap = 4;\n\n    // 地形数据\n    this.tiles = [];\n    this.platforms = [];\n\n    // 初始化地形\n    this.generateTerrain();\n  }\n  return _createClass(TerrainGenerator, [{\n    key: \"generateTerrain\",\n    value: function generateTerrain() {\n      var _this = this;\n      // 初始化瓦片数组\n      this.tiles = Array(Math.ceil(this.height / this.tileSize)).fill().map(function () {\n        return Array(Math.ceil(_this.width / _this.tileSize)).fill(0);\n      });\n\n      // 生成地面\n      var groundHeight = Math.floor(this.height * 0.8 / this.tileSize);\n      for (var x = 0; x < this.tiles[0].length; x++) {\n        for (var y = groundHeight; y < this.tiles.length; y++) {\n          this.tiles[y][x] = 1;\n        }\n      }\n\n      // 生成平台\n      var currentX = 2;\n      while (currentX < this.tiles[0].length - 2) {\n        var platformWidth = Math.floor(Math.random() * (this.platformMaxWidth - this.platformMinWidth + 1)) + this.platformMinWidth;\n        var gap = Math.floor(Math.random() * (this.platformMaxGap - this.platformMinGap + 1)) + this.platformMinGap;\n        var platformY = Math.floor(groundHeight * Math.random() * 0.7) + 3;\n        if (currentX + platformWidth < this.tiles[0].length - 2) {\n          for (var _x = currentX; _x < currentX + platformWidth; _x++) {\n            this.tiles[platformY][_x] = 1;\n          }\n          this.platforms.push({\n            x: currentX * this.tileSize,\n            y: platformY * this.tileSize,\n            width: platformWidth * this.tileSize,\n            height: this.tileSize\n          });\n        }\n        currentX += platformWidth + gap;\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var camera = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        x: 0,\n        y: 0\n      };\n      var startX = Math.max(0, Math.floor(camera.x / this.tileSize));\n      var endX = Math.min(this.tiles[0].length, Math.ceil((camera.x + ctx.canvas.width) / this.tileSize));\n      var startY = Math.max(0, Math.floor(camera.y / this.tileSize));\n      var endY = Math.min(this.tiles.length, Math.ceil((camera.y + ctx.canvas.height) / this.tileSize));\n      for (var y = startY; y < endY; y++) {\n        for (var x = startX; x < endX; x++) {\n          if (this.tiles[y][x] === 1) {\n            var drawX = x * this.tileSize - camera.x;\n            var drawY = y * this.tileSize - camera.y;\n\n            // 绘制地形瓦片\n            ctx.fillStyle = '#4a4a4a';\n            ctx.fillRect(drawX, drawY, this.tileSize, this.tileSize);\n\n            // 添加简单纹理\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\n            ctx.fillRect(drawX + 2, drawY + 2, this.tileSize - 4, this.tileSize - 4);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"checkCollision\",\n    value: function checkCollision(entity) {\n      var left = Math.floor(entity.x / this.tileSize);\n      var right = Math.ceil((entity.x + entity.width) / this.tileSize);\n      var top = Math.floor(entity.y / this.tileSize);\n      var bottom = Math.ceil((entity.y + entity.height) / this.tileSize);\n      for (var y = top; y < bottom; y++) {\n        for (var x = left; x < right; x++) {\n          if (y >= 0 && y < this.tiles.length && x >= 0 && x < this.tiles[0].length) {\n            if (this.tiles[y][x] === 1) {\n              var tileLeft = x * this.tileSize;\n              var tileRight = (x + 1) * this.tileSize;\n              var tileTop = y * this.tileSize;\n              var tileBottom = (y + 1) * this.tileSize;\n              var overlapLeft = entity.x + entity.width - tileLeft;\n              var overlapRight = tileRight - entity.x;\n              var overlapTop = entity.y + entity.height - tileTop;\n              var overlapBottom = tileBottom - entity.y;\n              var overlaps = [{\n                dir: 'left',\n                amount: overlapLeft\n              }, {\n                dir: 'right',\n                amount: overlapRight\n              }, {\n                dir: 'top',\n                amount: overlapTop\n              }, {\n                dir: 'bottom',\n                amount: overlapBottom\n              }];\n              var minOverlap = overlaps.reduce(function (min, current) {\n                return current.amount < min.amount ? current : min;\n              });\n              return {\n                collision: true,\n                direction: minOverlap.dir,\n                amount: minOverlap.amount\n              };\n            }\n          }\n        }\n      }\n      return {\n        collision: false\n      };\n    }\n  }, {\n    key: \"getTileAt\",\n    value: function getTileAt(x, y) {\n      var tileX = Math.floor(x / this.tileSize);\n      var tileY = Math.floor(y / this.tileSize);\n      if (tileY >= 0 && tileY < this.tiles.length && tileX >= 0 && tileX < this.tiles[0].length) {\n        return this.tiles[tileY][tileX];\n      }\n      return 0;\n    }\n  }]);\n}();\nexport { TerrainGenerator as default };","map":{"version":3,"names":["TerrainGenerator","width","height","tileSize","arguments","length","undefined","_classCallCheck","platformMinWidth","platformMaxWidth","platformMinGap","platformMaxGap","tiles","platforms","generateTerrain","_createClass","key","value","_this","Array","Math","ceil","fill","map","groundHeight","floor","x","y","currentX","platformWidth","random","gap","platformY","push","draw","ctx","camera","startX","max","endX","min","canvas","startY","endY","drawX","drawY","fillStyle","fillRect","checkCollision","entity","left","right","top","bottom","tileLeft","tileRight","tileTop","tileBottom","overlapLeft","overlapRight","overlapTop","overlapBottom","overlaps","dir","amount","minOverlap","reduce","current","collision","direction","getTileAt","tileX","tileY","default"],"sources":["D:/slj_doc/game_2/src/game/TerrainGenerator.js"],"sourcesContent":["export default class TerrainGenerator {\n  constructor(width, height, tileSize = 32) {\n    this.width = width;\n    this.height = height;\n    this.tileSize = tileSize;\n    \n    // 地形配置\n    this.platformMinWidth = 3;\n    this.platformMaxWidth = 8;\n    this.platformMinGap = 2;\n    this.platformMaxGap = 4;\n    \n    // 地形数据\n    this.tiles = [];\n    this.platforms = [];\n    \n    // 初始化地形\n    this.generateTerrain();\n  }\n\n  generateTerrain() {\n    // 初始化瓦片数组\n    this.tiles = Array(Math.ceil(this.height / this.tileSize))\n      .fill()\n      .map(() => Array(Math.ceil(this.width / this.tileSize)).fill(0));\n    \n    // 生成地面\n    const groundHeight = Math.floor(this.height * 0.8 / this.tileSize);\n    for (let x = 0; x < this.tiles[0].length; x++) {\n      for (let y = groundHeight; y < this.tiles.length; y++) {\n        this.tiles[y][x] = 1;\n      }\n    }\n    \n    // 生成平台\n    let currentX = 2;\n    while (currentX < this.tiles[0].length - 2) {\n      const platformWidth = Math.floor(\n        Math.random() * (this.platformMaxWidth - this.platformMinWidth + 1)\n      ) + this.platformMinWidth;\n      \n      const gap = Math.floor(\n        Math.random() * (this.platformMaxGap - this.platformMinGap + 1)\n      ) + this.platformMinGap;\n      \n      const platformY = Math.floor(groundHeight * Math.random() * 0.7) + 3;\n      \n      if (currentX + platformWidth < this.tiles[0].length - 2) {\n        for (let x = currentX; x < currentX + platformWidth; x++) {\n          this.tiles[platformY][x] = 1;\n        }\n        \n        this.platforms.push({\n          x: currentX * this.tileSize,\n          y: platformY * this.tileSize,\n          width: platformWidth * this.tileSize,\n          height: this.tileSize\n        });\n      }\n      \n      currentX += platformWidth + gap;\n    }\n  }\n\n  draw(ctx, camera = { x: 0, y: 0 }) {\n    const startX = Math.max(0, Math.floor(camera.x / this.tileSize));\n    const endX = Math.min(\n      this.tiles[0].length,\n      Math.ceil((camera.x + ctx.canvas.width) / this.tileSize)\n    );\n    const startY = Math.max(0, Math.floor(camera.y / this.tileSize));\n    const endY = Math.min(\n      this.tiles.length,\n      Math.ceil((camera.y + ctx.canvas.height) / this.tileSize)\n    );\n    \n    for (let y = startY; y < endY; y++) {\n      for (let x = startX; x < endX; x++) {\n        if (this.tiles[y][x] === 1) {\n          const drawX = x * this.tileSize - camera.x;\n          const drawY = y * this.tileSize - camera.y;\n          \n          // 绘制地形瓦片\n          ctx.fillStyle = '#4a4a4a';\n          ctx.fillRect(drawX, drawY, this.tileSize, this.tileSize);\n          \n          // 添加简单纹理\n          ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\n          ctx.fillRect(\n            drawX + 2,\n            drawY + 2,\n            this.tileSize - 4,\n            this.tileSize - 4\n          );\n        }\n      }\n    }\n  }\n\n  checkCollision(entity) {\n    const left = Math.floor(entity.x / this.tileSize);\n    const right = Math.ceil((entity.x + entity.width) / this.tileSize);\n    const top = Math.floor(entity.y / this.tileSize);\n    const bottom = Math.ceil((entity.y + entity.height) / this.tileSize);\n    \n    for (let y = top; y < bottom; y++) {\n      for (let x = left; x < right; x++) {\n        if (y >= 0 && y < this.tiles.length && x >= 0 && x < this.tiles[0].length) {\n          if (this.tiles[y][x] === 1) {\n            const tileLeft = x * this.tileSize;\n            const tileRight = (x + 1) * this.tileSize;\n            const tileTop = y * this.tileSize;\n            const tileBottom = (y + 1) * this.tileSize;\n            \n            const overlapLeft = entity.x + entity.width - tileLeft;\n            const overlapRight = tileRight - entity.x;\n            const overlapTop = entity.y + entity.height - tileTop;\n            const overlapBottom = tileBottom - entity.y;\n            \n            const overlaps = [\n              { dir: 'left', amount: overlapLeft },\n              { dir: 'right', amount: overlapRight },\n              { dir: 'top', amount: overlapTop },\n              { dir: 'bottom', amount: overlapBottom }\n            ];\n            \n            const minOverlap = overlaps.reduce((min, current) => \n              current.amount < min.amount ? current : min\n            );\n            \n            return {\n              collision: true,\n              direction: minOverlap.dir,\n              amount: minOverlap.amount\n            };\n          }\n        }\n      }\n    }\n    \n    return { collision: false };\n  }\n\n  getTileAt(x, y) {\n    const tileX = Math.floor(x / this.tileSize);\n    const tileY = Math.floor(y / this.tileSize);\n    \n    if (tileY >= 0 && tileY < this.tiles.length && tileX >= 0 && tileX < this.tiles[0].length) {\n      return this.tiles[tileY][tileX];\n    }\n    \n    return 0;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}